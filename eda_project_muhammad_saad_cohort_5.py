# -*- coding: utf-8 -*-
"""EDA project_Muhammad Saad cohort 5

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nCGLQrTXucudSz8w9s9NhzmSuHVQEU2L
"""

from google.colab import files
uploaded = files.upload()

"""Installing Fuzzywuzzzy library"""

!pip install fuzzywuzzy

"""Importing

"""

import pandas as pd
df = pd.read_excel("Scarped Zameen.com.xlsx")
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import re
from fuzzywuzzy import process
from sklearn.preprocessing import LabelEncoder

"""Defining the Dataset"""

# Shape of dataset
df.shape

# Column names and types
df.info()

# Check for duplicates
df.duplicated().sum()

# Summary statistics
df.describe(include='all')

"""Cleaning the Data"""

# Loading Excel
df = pd.read_excel("Scarped Zameen.com.xlsx")

# Selecting important columns
df = df[['Title', 'City', 'Type', 'Area', 'Price', 'Purpose', 'Location', 'Description', 'Bedrooms', 'Bathrooms']].copy()

# Price cleaning
def clean_price(price_str):
    if isinstance(price_str, str):
        price_str = price_str.replace('PKR', '').replace('\n', '').replace(',', '').strip()
        if 'Arab' in price_str:
            return float(re.findall(r'\d+\.?\d*', price_str)[0]) * 1e9
        elif 'Crore' in price_str:
            return float(re.findall(r'\d+\.?\d*', price_str)[0]) * 1e7
        elif 'Lakh' in price_str:
            return float(re.findall(r'\d+\.?\d*', price_str)[0]) * 1e5
        elif 'Thousand' in price_str:
            return float(re.findall(r'\d+\.?\d*', price_str)[0]) * 1e3
        elif re.match(r'^\d+\.?\d*$', price_str):
            return float(price_str)
    return np.nan

df['Price_Clean'] = df['Price'].apply(clean_price)

# Area cleaning
unit_conversion = {
    'Sq. Yd.': 9.0,
    'Sq. Ft.': 1.0,
    'Marla': 272.25,
    'Kanal': 5445.0,
    'Sq. Meter': 10.7639
}

def convert_area(area_str):
    if isinstance(area_str, str):
        match = re.match(r'(\d+\.?\d*)\s*([A-Za-z. ]+)', area_str.strip())
        if match:
            size = float(match.group(1))
            unit = match.group(2).strip()
            factor = unit_conversion.get(unit, np.nan)
            if not np.isnan(factor):
                return size * factor
    return np.nan

df['Area_Sqft'] = df['Area'].apply(convert_area)

# Converting beds & baths to numbers
df['Bedrooms'] = pd.to_numeric(df['Bedrooms'], errors='coerce')
df['Bathrooms'] = pd.to_numeric(df['Bathrooms'], errors='coerce')

# Price per square foot
df['Price_per_Sqft'] = df['Price_Clean'] / df['Area_Sqft']

# View summary
print(df[['Price_Clean', 'Area_Sqft', 'Price_per_Sqft']].describe())

"""Handling missing Values"""

# Cleaning the 'Price' column
# We convert prices like 'PKR 25,000,000' → 25000000.0 (float)
# This method works for numeric-only values, not for "Crore/Lakh" text-based formats
df['Price_Clean'] = df['Price'].astype(str).str.replace(',', '').str.extract(r'(\d+\.?\d*)').astype(float)

#  Cleaning the 'Area' column
# Similar cleaning: extract numeric area value from strings like '1,200 Sq. Ft.' → 1200.0
df['Area_Sqft'] = df['Area'].astype(str).str.replace(',', '').str.extract(r'(\d+\.?\d*)').astype(float)

# Checking for missing values after cleaning
# Helps us understand which columns still have NaNs before analysis
print("Missing values after cleaning:\n")
print(df.isnull().sum())

#  Dropping rows with missing essential fields
# We remove listings with no price, area, bedroom, or bathroom info — they're not useful for analysis
df.dropna(subset=['Price_Clean', 'Area_Sqft', 'Bedrooms', 'Bathrooms'], inplace=True)

"""Remove Outliers"""

# Outlier removal using IQR
Q1 = df['Price_Clean'].quantile(0.25)
Q3 = df['Price_Clean'].quantile(0.75)
IQR = Q3 - Q1

df = df[(df['Price_Clean'] >= Q1 - 1.5 * IQR) & (df['Price_Clean'] <= Q3 + 1.5 * IQR)]

"""UNIVARIATE ANALYSIS

"""

# Setting a clean visual style for all plots using seaborn
sns.set(style="whitegrid")

# ------------------ Univariate Analysis ------------------

# Plot 1: Distribution of Property Prices
# This will help us understand how most properties are priced —
# are they clustered at low-end, mid-range, or luxury?
plt.figure(figsize=(10, 6))
sns.histplot(df['Price_Clean'], bins=50, kde=True)
plt.title('Distribution of Property Prices')
plt.xlabel('Price (PKR)')
plt.ylabel('Count')

# To avoid outliers from distorting the plot, we limit x-axis to the 99th percentile
plt.xlim(0, df['Price_Clean'].quantile(0.99))
plt.tight_layout()
plt.savefig('univariate_price_distribution.png')  # Save for report
plt.show()

# Plot 2: Distribution of Property Area (in sqft)
# Similar to the price plot, this shows us how big most properties are in terms of area
plt.figure(figsize=(10, 6))
sns.histplot(df['Area_Sqft'], bins=50, kde=True)
plt.title('Distribution of Property Area (Sqft)')
plt.xlabel('Area (Sqft)')
plt.ylabel('Count')

# Again, we limit the x-axis to 99th percentile to reduce skewness from extreme values
plt.xlim(0, df['Area_Sqft'].quantile(0.99))
plt.tight_layout()
plt.savefig('univariate_area_distribution.png')
plt.show()

# Plot 3: Top 10 Cities by Number of Listings
# This bar chart helps us identify which cities are most active on Zameen.com
plt.figure(figsize=(12, 6))
city_counts = df['City'].value_counts().head(10)
sns.barplot(x=city_counts.index, y=city_counts.values)
plt.title('Top 10 Cities by Number of Listings')
plt.ylabel('Listing Count')
plt.xlabel('City')
plt.xticks(rotation=45)  # Rotate city names for better readability
plt.tight_layout()
plt.savefig('univariate_city_counts.png')
plt.show()
# Plot 4: Count of Listings by Property Type
# This shows the most common types of properties (e.g., House, Plot, Flat)
plt.figure(figsize=(10, 5))
type_counts = df['Type'].value_counts()
sns.barplot(x=type_counts.index, y=type_counts.values)
plt.title("Listings by Property Type")
plt.ylabel("Count")
plt.xlabel("Property Type")
plt.xticks(rotation=45)
plt.tight_layout()
plt.savefig('univariate_property_type_counts.png')
plt.show()
# Plot 5: Distribution of Bedrooms
# This helps us see whether listings are more commonly 2-bed, 3-bed, etc.
plt.figure(figsize=(10, 5))
sns.countplot(data=df, x='Bedrooms', order=sorted(df['Bedrooms'].dropna().unique()))
plt.title("Distribution of Number of Bedrooms")
plt.xlabel("Bedrooms")
plt.ylabel("Count")
plt.tight_layout()
plt.savefig('univariate_bedroom_distribution.png')
plt.show()
# Plot 6: Distribution of Bathrooms
# Similar to bedrooms, this gives an idea of typical bathroom configurations
plt.figure(figsize=(10, 5))
sns.countplot(data=df, x='Bathrooms', order=sorted(df['Bathrooms'].dropna().unique()))
plt.title("Distribution of Number of Bathrooms")
plt.xlabel("Bathrooms")
plt.ylabel("Count")
plt.tight_layout()
plt.savefig('univariate_bathroom_distribution.png')
plt.show()

"""Bivariate Analysis"""

# 1. Price per Sqft by Property Type
plt.figure(figsize=(12, 6))
sns.boxplot(data=df, x='Type', y='Price_per_Sqft')
plt.title('Price per Sqft by Property Type')
plt.xticks(rotation=45)
plt.tight_layout()
plt.savefig('bivariate_price_per_sqft_type.png')
plt.show()


# 2. Price by City
plt.figure(figsize=(12, 6))
top_cities = df['City'].value_counts().head(10).index
sns.boxplot(data=df[df['City'].isin(top_cities)], x='City', y='Price_Clean')
plt.title('Price Distribution by City')
plt.xticks(rotation=45)
plt.tight_layout()
plt.savefig('bivariate_price_by_city.png')
plt.show()

# 3. Bedrooms vs Price
plt.figure(figsize=(10, 6))
sns.boxplot(x='Bedrooms', y='Price_Clean', data=df)
plt.title("Price by Number of Bedrooms")
plt.xlabel("Bedrooms")
plt.ylabel("Price (PKR)")
plt.tight_layout()
plt.savefig('bivariate_price_by_bedrooms.png')
plt.show()

# 4. Area vs Price Scatter Plot
plt.figure(figsize=(10, 6))
sns.scatterplot(data=df, x='Area_Sqft', y='Price_Clean', hue='City', alpha=0.4)
plt.title('Area vs Price by City')
plt.xlabel('Area (Sqft)')
plt.ylabel('Price (PKR)')
plt.xlim(0, df['Area_Sqft'].quantile(0.99))
plt.ylim(0, df['Price_Clean'].quantile(0.99))
plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')
plt.tight_layout()
plt.savefig('bivariate_area_vs_price.png')
plt.show()

# 5. Correlation Heatmap
plt.figure(figsize=(8, 6))
sns.heatmap(df[['Price_Clean', 'Area_Sqft', 'Bedrooms', 'Bathrooms', 'Price_per_Sqft']].corr(), annot=True, cmap='coolwarm')
plt.title('Correlation Between Numerical Features')
plt.tight_layout()
plt.savefig('bivariate_correlation_heatmap.png')
plt.show()

"""General Insights"""

# Step 1: Calculate the median price per city
# Using median to avoid distortion from extreme luxury listings
city_median_prices = df.groupby("City")["Price_Clean"].median().sort_values(ascending=False)

# Step 2: Print the full sorted list
print("🏙️ Median Property Prices by City (highest to lowest):\n")
print(city_median_prices)

# Step 3: Plot Top 10 Cities by Median Price
# Gives a visual sense of where properties are most expensive
top_city_prices = city_median_prices.head(10)

plt.figure(figsize=(10, 6))
sns.barplot(x=top_city_prices.values, y=top_city_prices.index, palette='viridis')
plt.title("Top 10 Cities by Median Property Price")
plt.xlabel("Median Price (PKR)")
plt.ylabel("City")
plt.tight_layout()
plt.savefig("bivariate_median_price_by_city.png")
plt.show()

"""Export Cleaned Data"""

df.to_csv("cleaned_zameen_data.csv", index=False)